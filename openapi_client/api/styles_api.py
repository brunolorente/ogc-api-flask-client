# coding: utf-8

"""
    Daraa

    This data store is offered by CubeWerx Inc. as a demonstration of its in-progress OGC API implementation.  # noqa: E501

    The version of the OpenAPI document: 9.3.45
    Contact: mgalluch@cubewerx.com
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from openapi_client.api_client import ApiClient
from openapi_client.exceptions import (
    ApiTypeError,
    ApiValueError
)


class StylesApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def collections_collection_id_styles_get(self, collection_id, **kwargs):  # noqa: E501
        """The set of styles available for the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_get(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: StyleSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collections_collection_id_styles_get_with_http_info(collection_id, **kwargs)  # noqa: E501
        else:
            (data) = self.collections_collection_id_styles_get_with_http_info(collection_id, **kwargs)  # noqa: E501
            return data

    def collections_collection_id_styles_get_with_http_info(self, collection_id, **kwargs):  # noqa: E501
        """The set of styles available for the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_get_with_http_info(collection_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: StyleSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['collection_id', 'f', 'pretty']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collection_id_styles_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in local_var_params or
                local_var_params['collection_id'] is None):
            raise ApiValueError("Missing the required parameter `collection_id` when calling `collections_collection_id_styles_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in local_var_params:
            path_params['collectionId'] = local_var_params['collection_id']  # noqa: E501

        query_params = []
        if 'f' in local_var_params:
            query_params.append(('f', local_var_params['f']))  # noqa: E501
        if 'pretty' in local_var_params:
            query_params.append(('pretty', local_var_params['pretty']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/vnd.ogc.sld+xml;version=1.1', 'application/vnd.ogc.sld+xml;version=1.0', 'text/html', 'application/problem+json', 'text/xml', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/collections/{collectionId}/styles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StyleSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collections_collection_id_styles_style_id_delete(self, collection_id, style_id, **kwargs):  # noqa: E501
        """Remove a style from the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_delete(collection_id, style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collections_collection_id_styles_style_id_delete_with_http_info(collection_id, style_id, **kwargs)  # noqa: E501
        else:
            (data) = self.collections_collection_id_styles_style_id_delete_with_http_info(collection_id, style_id, **kwargs)  # noqa: E501
            return data

    def collections_collection_id_styles_style_id_delete_with_http_info(self, collection_id, style_id, **kwargs):  # noqa: E501
        """Remove a style from the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_delete_with_http_info(collection_id, style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['collection_id', 'style_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collection_id_styles_style_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in local_var_params or
                local_var_params['collection_id'] is None):
            raise ApiValueError("Missing the required parameter `collection_id` when calling `collections_collection_id_styles_style_id_delete`")  # noqa: E501
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `collections_collection_id_styles_style_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in local_var_params:
            path_params['collectionId'] = local_var_params['collection_id']  # noqa: E501
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/collections/{collectionId}/styles/{styleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collections_collection_id_styles_style_id_get(self, collection_id, style_id, **kwargs):  # noqa: E501
        """A style as it pertains to the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_get(collection_id, style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  If \"json\" is specified, a metadata document is returned.  If \"sld11\" or \"sld10\" is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \"sld11style\" or \"sld10style\" is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collections_collection_id_styles_style_id_get_with_http_info(collection_id, style_id, **kwargs)  # noqa: E501
        else:
            (data) = self.collections_collection_id_styles_style_id_get_with_http_info(collection_id, style_id, **kwargs)  # noqa: E501
            return data

    def collections_collection_id_styles_style_id_get_with_http_info(self, collection_id, style_id, **kwargs):  # noqa: E501
        """A style as it pertains to the specified collection.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_get_with_http_info(collection_id, style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  If \"json\" is specified, a metadata document is returned.  If \"sld11\" or \"sld10\" is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \"sld11style\" or \"sld10style\" is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['collection_id', 'style_id', 'f', 'pretty']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collection_id_styles_style_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in local_var_params or
                local_var_params['collection_id'] is None):
            raise ApiValueError("Missing the required parameter `collection_id` when calling `collections_collection_id_styles_style_id_get`")  # noqa: E501
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `collections_collection_id_styles_style_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in local_var_params:
            path_params['collectionId'] = local_var_params['collection_id']  # noqa: E501
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []
        if 'f' in local_var_params:
            query_params.append(('f', local_var_params['f']))  # noqa: E501
        if 'pretty' in local_var_params:
            query_params.append(('pretty', local_var_params['pretty']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.ogc.sld+xml; version=1.1', 'application/vnd.ogc.sld+xml; version=1.0', 'application/vnd.ogc.sld+xml; version=1.1; styleOnly=true', 'application/vnd.ogc.sld+xml; version=1.0; styleOnly=true', 'text/html', 'application/problem+json', 'text/xml', 'application/json', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/collections/{collectionId}/styles/{styleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def collections_collection_id_styles_style_id_put(self, collection_id, style_id, body, **kwargs):  # noqa: E501
        """Add or update a style for the specified collection, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_put(collection_id, style_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :param str body: The definition of a style for this collection.  This can by a full StyledLayerDescriptor (with a single NamedLayer with a single UserStyle) or just a UserStyle.  If the UserStyle name/ID is present, it must match the style ID specified in the URL. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before updating or creating it on the server (returning code 201 on successful creation, code 204 on successful update and code 400 if validation fails), a value of \"no\" updates or creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without updating or creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.collections_collection_id_styles_style_id_put_with_http_info(collection_id, style_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.collections_collection_id_styles_style_id_put_with_http_info(collection_id, style_id, body, **kwargs)  # noqa: E501
            return data

    def collections_collection_id_styles_style_id_put_with_http_info(self, collection_id, style_id, body, **kwargs):  # noqa: E501
        """Add or update a style for the specified collection, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.collections_collection_id_styles_style_id_put_with_http_info(collection_id, style_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str collection_id: The identifier of a collection in this data store. (required)
        :param str style_id: The identifier of a style in this data store. (required)
        :param str body: The definition of a style for this collection.  This can by a full StyledLayerDescriptor (with a single NamedLayer with a single UserStyle) or just a UserStyle.  If the UserStyle name/ID is present, it must match the style ID specified in the URL. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before updating or creating it on the server (returning code 201 on successful creation, code 204 on successful update and code 400 if validation fails), a value of \"no\" updates or creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without updating or creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['collection_id', 'style_id', 'body', 'validate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method collections_collection_id_styles_style_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'collection_id' is set
        if ('collection_id' not in local_var_params or
                local_var_params['collection_id'] is None):
            raise ApiValueError("Missing the required parameter `collection_id` when calling `collections_collection_id_styles_style_id_put`")  # noqa: E501
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `collections_collection_id_styles_style_id_put`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `collections_collection_id_styles_style_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'collection_id' in local_var_params:
            path_params['collectionId'] = local_var_params['collection_id']  # noqa: E501
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []
        if 'validate' in local_var_params:
            query_params.append(('validate', local_var_params['validate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/vnd.ogc.sld+xml; version=1.1', 'application/vnd.ogc.sld+xml; version=1.0'])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/collections/{collectionId}/styles/{styleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_get(self, **kwargs):  # noqa: E501
        """The set of styles available in this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_get(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: StyleSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.styles_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def styles_get_with_http_info(self, **kwargs):  # noqa: E501
        """The set of styles available in this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: StyleSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['f', 'pretty']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'f' in local_var_params:
            query_params.append(('f', local_var_params['f']))  # noqa: E501
        if 'pretty' in local_var_params:
            query_params.append(('pretty', local_var_params['pretty']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json', 'application/vnd.ogc.sld+xml;version=1.1', 'application/vnd.ogc.sld+xml;version=1.0', 'text/html', 'application/problem+json', 'text/xml', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='StyleSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_post(self, body, **kwargs):  # noqa: E501
        """Add a new style to this data store, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_post(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, the style must not already exist, and all referenced collections must exist and be of a compatible type. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before creating it on the server (returning code 201 on successful creation and code 400 if validation fails), a value of \"no\" creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_post_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.styles_post_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def styles_post_with_http_info(self, body, **kwargs):  # noqa: E501
        """Add a new style to this data store, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_post_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str body: The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, the style must not already exist, and all referenced collections must exist and be of a compatible type. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before creating it on the server (returning code 201 on successful creation and code 400 if validation fails), a value of \"no\" creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body', 'validate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_post" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `styles_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'validate' in local_var_params:
            query_params.append(('validate', local_var_params['validate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/vnd.ogc.sld+xml; version=1.1', 'application/vnd.ogc.sld+xml; version=1.0'])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_style_id_delete(self, style_id, **kwargs):  # noqa: E501
        """Remove a style from this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_delete(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_style_id_delete_with_http_info(style_id, **kwargs)  # noqa: E501
        else:
            (data) = self.styles_style_id_delete_with_http_info(style_id, **kwargs)  # noqa: E501
            return data

    def styles_style_id_delete_with_http_info(self, style_id, **kwargs):  # noqa: E501
        """Remove a style from this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_delete_with_http_info(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['style_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_style_id_delete" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `styles_style_id_delete`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles/{styleId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_style_id_get(self, style_id, **kwargs):  # noqa: E501
        """A style in this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_get(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  If \"json\" is specified, a metadata document is returned.  If \"sld11\" or \"sld10\" is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \"sld11style\" or \"sld10style\" is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_style_id_get_with_http_info(style_id, **kwargs)  # noqa: E501
        else:
            (data) = self.styles_style_id_get_with_http_info(style_id, **kwargs)  # noqa: E501
            return data

    def styles_style_id_get_with_http_info(self, style_id, **kwargs):  # noqa: E501
        """A style in this data store.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_get_with_http_info(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  If \"json\" is specified, a metadata document is returned.  If \"sld11\" or \"sld10\" is specified, the style is returned as a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  If \"sld11style\" or \"sld10style\" is specified, the style is returned as a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.
        :param bool pretty: Whether or not the output should be pretty-formatted (with whitespace, etc.).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['style_id', 'f', 'pretty']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_style_id_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `styles_style_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []
        if 'f' in local_var_params:
            query_params.append(('f', local_var_params['f']))  # noqa: E501
        if 'pretty' in local_var_params:
            query_params.append(('pretty', local_var_params['pretty']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/vnd.ogc.sld+xml; version=1.1', 'application/vnd.ogc.sld+xml; version=1.0', 'application/vnd.ogc.sld+xml; version=1.1; styleOnly=true', 'application/vnd.ogc.sld+xml; version=1.0; styleOnly=true', 'text/html', 'application/problem+json', 'text/xml', 'application/json', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles/{styleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_style_id_legend_get(self, style_id, **kwargs):  # noqa: E501
        """A legend image showing a graphical representation of the specified style, broken down by each of the collections that it's capable of rendering.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_legend_get(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :param bool transparent: Whether or not the background of the image should be transparent (when supported by the requested image format).
        :param str bgcolor: Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
        :param str textcolor: Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  A value of \"jop\" (content type \"image/x-jpegorpng\") indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \"wkb\" indicates CubeWerx's raster extension to the Well-Known-Binary format.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_style_id_legend_get_with_http_info(style_id, **kwargs)  # noqa: E501
        else:
            (data) = self.styles_style_id_legend_get_with_http_info(style_id, **kwargs)  # noqa: E501
            return data

    def styles_style_id_legend_get_with_http_info(self, style_id, **kwargs):  # noqa: E501
        """A legend image showing a graphical representation of the specified style, broken down by each of the collections that it's capable of rendering.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_legend_get_with_http_info(style_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a style in this data store. (required)
        :param bool transparent: Whether or not the background of the image should be transparent (when supported by the requested image format).
        :param str bgcolor: Hexadecimal red-green-blue color value for the background color.  If not specified, the background color specified by the style (0xFFFFFF by default) will be used.
        :param str textcolor: Hexadecimal red-green-blue color value for the text color.  If not specified, a color that contrasts the background color will be used.
        :param str f: A token indicating the content type to return.  Overrides the HTTP \"Accept\" header if present.  A value of \"jop\" (content type \"image/x-jpegorpng\") indicates that either JPEG or PNG should be returned, whichever the server deems to be most appropriate for this particular image.  A value of \"wkb\" indicates CubeWerx's raster extension to the Well-Known-Binary format.
        :return: file
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['style_id', 'transparent', 'bgcolor', 'textcolor', 'f']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_style_id_legend_get" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `styles_style_id_legend_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []
        if 'transparent' in local_var_params:
            query_params.append(('transparent', local_var_params['transparent']))  # noqa: E501
        if 'bgcolor' in local_var_params:
            query_params.append(('bgcolor', local_var_params['bgcolor']))  # noqa: E501
        if 'textcolor' in local_var_params:
            query_params.append(('textcolor', local_var_params['textcolor']))  # noqa: E501
        if 'f' in local_var_params:
            query_params.append(('f', local_var_params['f']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['image/x-jpegorpng', 'image/jpeg', 'image/png', 'image/tiff', 'image/gif', 'application/x-cubewerx-wkb', 'application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles/{styleId}/legend', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='file',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def styles_style_id_put(self, style_id, body, **kwargs):  # noqa: E501
        """Add a new style to this data store, redefine an existing style, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_put(style_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a (new or existing) style in this data store. (required)
        :param str body: The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, all referenced collections must exist and be of the compatible type.  If this style already exists, its definition will get updated on the server.  Otherwise it will get created on the server. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before creating it on the server (returning code 201 on successful creation and code 400 if validation fails), a value of \"no\" creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.styles_style_id_put_with_http_info(style_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.styles_style_id_put_with_http_info(style_id, body, **kwargs)  # noqa: E501
            return data

    def styles_style_id_put_with_http_info(self, style_id, body, **kwargs):  # noqa: E501
        """Add a new style to this data store, redefine an existing style, or just validate a style.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.styles_style_id_put_with_http_info(style_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str style_id: The identifier of a (new or existing) style in this data store. (required)
        :param str body: The definition of an OGG-API style.  There are two ways of representing such a style in SLD.  The first is by using a SymLayerSet with one or more NamedLayers, each of which defines exactly one UserStyle (whose name is the ID of the style being defined), each of which has exactly one FeatureTypeStyle (whose FeatureTypeName is implicitly or explicitly the same as that of the NamedLayer).  The second is by using a UserStyle (as a top-level element) with one or more FeatureTypeStyles, each of which explicitly specifies a FeatureTypeName indicating the collection that that FeatureTypeStyle is for.  Either way, all referenced collections must exist and be of the compatible type.  If this style already exists, its definition will get updated on the server.  Otherwise it will get created on the server. (required)
        :param str validate: Whether or not to validate (or only validate) the style.  A value of \"yes\" validates the style before creating it on the server (returning code 201 on successful creation and code 400 if validation fails), a value of \"no\" creates the style without validation (although some validation may still occur), and a value of \"only\" just validates the style without creating it on the server (returning code 204 on successful validation and code 400 if validation fails).
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['style_id', 'body', 'validate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method styles_style_id_put" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'style_id' is set
        if ('style_id' not in local_var_params or
                local_var_params['style_id'] is None):
            raise ApiValueError("Missing the required parameter `style_id` when calling `styles_style_id_put`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in local_var_params or
                local_var_params['body'] is None):
            raise ApiValueError("Missing the required parameter `body` when calling `styles_style_id_put`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'style_id' in local_var_params:
            path_params['styleId'] = local_var_params['style_id']  # noqa: E501

        query_params = []
        if 'validate' in local_var_params:
            query_params.append(('validate', local_var_params['validate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/problem+json', 'text/xml', 'text/html', 'application/json', ])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/vnd.ogc.sld+xml; version=1.1', 'application/vnd.ogc.sld+xml; version=1.0'])  # noqa: E501

        # Authentication setting
        auth_settings = ['cwApiKeyHeader', 'cwApiKeyQuery', 'cwAuth', 'httpBearer', 'oauth2', 'openIdConnect', 'openIdConnect1']  # noqa: E501

        return self.api_client.call_api(
            '/styles/{styleId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
